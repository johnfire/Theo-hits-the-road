#!/usr/bin/env bash
# Pre-commit hook: linting + targeted tests.
# Bypass with: git commit --no-verify  (use sparingly)
#
# One-time setup (run once per clone):
#   git config core.hooksPath .githooks

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

ROOT="$(git rev-parse --show-toplevel)"
PYTHON="$ROOT/venv/bin/python"
if [ ! -f "$PYTHON" ]; then
    PYTHON="python"
fi

# Staged Python files only
STAGED_PY=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

if [ -z "$STAGED_PY" ]; then
    echo "No Python files staged — skipping pre-commit checks."
    exit 0
fi

echo "Pre-commit: checking $(echo "$STAGED_PY" | wc -l | tr -d ' ') staged Python file(s)..."

# ── Linting (fatal errors only: syntax, undefined names) ─────────────────────
LINT_OUT=$("$PYTHON" -m flake8 \
    --select=E9,F63,F7,F82 \
    --show-source \
    --statistics \
    $STAGED_PY 2>&1)
LINT_EXIT=$?

if [ $LINT_EXIT -ne 0 ]; then
    echo -e "${RED}✗ Linting failed:${NC}"
    echo "$LINT_OUT"
    echo ""
    echo -e "${YELLOW}Fix the errors above, then re-stage and commit.${NC}"
    echo "  To bypass (use sparingly): git commit --no-verify"
    exit 1
fi
echo -e "${GREEN}✓ Linting passed${NC}"

# ── Tests: map staged files → relevant test files ────────────────────────────
# Declares which test file covers each source file.
# Falls back to the full suite for anything not in the map.
declare -A SOURCE_TO_TEST
SOURCE_TO_TEST["artcrm/engine/crm.py"]="tests/unit/test_crm.py"
SOURCE_TO_TEST["artcrm/engine/ai_planner.py"]="tests/unit/test_ai_planner.py"
SOURCE_TO_TEST["artcrm/engine/email_composer.py"]="tests/unit/test_email_composer.py"
SOURCE_TO_TEST["artcrm/engine/lead_scout.py"]="tests/unit/test_lead_scout.py"
SOURCE_TO_TEST["artcrm/bus/events.py"]="tests/unit/test_events.py"
SOURCE_TO_TEST["artcrm/models/__init__.py"]="tests/unit/test_models.py"
SOURCE_TO_TEST["artcrm/config.py"]="tests/unit/test_config.py"

FULL_SUITE=0
declare -A TESTS_NEEDED  # use associative array to deduplicate

for f in $STAGED_PY; do
    if [[ "$f" == tests/unit/test_*.py ]]; then
        # Staged file is itself a test file — run it directly
        TESTS_NEEDED["$f"]=1
    elif [ -n "${SOURCE_TO_TEST[$f]+_}" ]; then
        # Known source file — run its mapped test file
        TESTS_NEEDED["${SOURCE_TO_TEST[$f]}"]=1
    else
        # Unknown file (new module, config change, etc.) — run full suite
        FULL_SUITE=1
        break
    fi
done

if [ $FULL_SUITE -eq 1 ]; then
    TEST_TARGET="tests/"
    echo "Running full test suite..."
else
    TEST_TARGET="${!TESTS_NEEDED[*]}"
    echo "Running targeted tests: $TEST_TARGET"
fi

TEST_OUT=$("$PYTHON" -m pytest $TEST_TARGET -q --no-header --tb=short 2>&1)
TEST_EXIT=$?

if [ $TEST_EXIT -ne 0 ]; then
    echo -e "${RED}✗ Tests failed:${NC}"
    echo "$TEST_OUT"
    echo ""
    echo -e "${YELLOW}Fix the failures above, then re-stage and commit.${NC}"
    echo "  To bypass (use sparingly): git commit --no-verify"
    exit 1
fi

# Show the summary line (last non-empty line of pytest output)
SUMMARY=$(echo "$TEST_OUT" | grep -E "passed|failed|error" | tail -1)
echo -e "${GREEN}✓ Tests passed${NC} — $SUMMARY"
exit 0
